import{_ as g}from"./chunks/ArticleMetadata.DArXzXOG.js";import{_ as y,m as D,a as C,u as p,B as e,e as s,x as h,ai as d,o as t,p as r,q as A,b5 as o,b6 as c,b7 as B,b8 as F,b9 as E,ba as u,bb as m,bc as v,bd as S,be as f,bf as b}from"./chunks/framework.DGhdORX1.js";import"./chunks/theme.C7H76Bwr.js";const G=JSON.parse('{"title":"前后端分离-登录页面","description":"","frontmatter":{"title":"前后端分离-登录页面","author":"vains","date":"2024-05-05 13:00","isTop":"fasle","categories":["认证服务集成"],"tags":["Vue","Spring Boot","Spring Security","Spring OAuth2 Authorization Server"],"showComment":false},"headers":[],"relativePath":"authorization-server/04-进阶教程/07-split-login-page.md","filePath":"authorization-server/04-进阶教程/07-split-login-page.md","lastUpdated":null}'),q={name:"authorization-server/04-进阶教程/07-split-login-page.md"},w=s("p",null,[s("strong",null,"今天的主题就是使用单独部署的登录页面替换认证服务器默认的登录页面(前后端分离时使用前端的登录页面)，目前在网上能搜到的很多都是理论，没有很好的一个示例，我就按照我自己的想法写了一个实现，给大家提供一个思路，如果有什么问题或者更好的想法可以在评论区提出，谢谢。")],-1),x=s("h1",{id:"实现思路分析",tabindex:"-1"},[h("实现思路分析 "),s("a",{class:"header-anchor",href:"#实现思路分析","aria-label":'Permalink to "实现思路分析"'},"​")],-1),R=d("",19),T=d("",6),_=d("",38),z=s("p",null,[s("s",null,[h("        在踩了不知道多少坑以后终于算是实现了这个东西，但是目前只支持不需要授权确认的客户端，如果需要授权确认那么就会在重定向至授权确认页面时因为获取不到登录信息而重定向至登录页面，这里也比较坑，没有能够更改授权确认请求的地方，只能另辟蹊径修改现在的RedisSecurityContextRepository从而使授权确认请求也能获取到认证信息，就是在获取认证信息后存入session中一份，因为从"),s("code",null,"/oauth2/authorize"),h("重定向至授权确认页面是同一个session，所以存入session后就可以获取了，但是我觉得既然都已经前后端分离了，也就没必要在加授权确认了；当然也不排除有需要这东西的人，后期看看有没有需要的，如果有需要的我会写一下扩展篇。")]),s("br"),s("br"),h("         现在改为通过sessionId串联认证服务与单独部署的登录页面的请求，也就不会出现只能获取一次认证信息的问题了，只要在同一个浏览器中访问认证服务，那么使用的session就只会是同一个，当从其它系统跳转至认证服务时只要登录过就不需要在登录了，可以直接根据浏览器与认证服务之间产生的session的id获取到对应的认证信息，认证信息的存活时间就是在redis中设置的key的存活时间。"),s("br"),s("br"),h("        虽然现在也是靠session关联，但现在将原先存储在session中的认证信息存储到了redis中，缩小了服务器存储session所需的空间，也可以通过sessionId将其关联起来，解决了认证服务与登录页面不在同一域从而因为session的不同而获取不到认证信息的问题。这也符合sso的特点，其它域名下的服务需要认证时需要跳转到登录页面登录，登录后另外的服务再次请求认证服务认证时就不需要认证了，可以直接获取到认证信息。 "),s("br"),s("br"),h("         本来想写点基础的东西，但是兄弟们太相信我了，净整些高端操作，唉 (╯°Д°)╯︵ ┻━┻ "),s("br")],-1);function P(i,O,H,j,I,M){const l=g,k=D("ClientOnly");return t(),C("div",null,[w,x,p(k,null,{default:e(()=>{var a,n;return[(((a=i.$frontmatter)==null?void 0:a.aside)??!0)&&(((n=i.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(t(),r(l,{key:0,article:i.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),R,p(k,null,{default:e(()=>{var a,n;return[(((a=i.$frontmatter)==null?void 0:a.aside)??!0)&&(((n=i.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(t(),r(l,{key:0,article:i.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),T,p(k,null,{default:e(()=>{var a,n;return[(((a=i.$frontmatter)==null?void 0:a.aside)??!0)&&(((n=i.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(t(),r(l,{key:0,article:i.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),_,p(k,null,{default:e(()=>{var a,n;return[(((a=i.$frontmatter)==null?void 0:a.aside)??!0)&&(((n=i.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(t(),r(l,{key:0,article:i.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),z])}const J=y(q,[["render",P]]);export{G as __pageData,J as default};
